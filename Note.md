# 算法笔记
 
我们学习数据结构和算法，要学习它的**由来**、**特性**、**适用的场景**以及**它能解决的问题**。
 
## 工具
 
### 等比数列求和公式
∑ = Sn = a1 + a2 + ... + an = a1 * (1 - qn) / (1 -q)
 
(特殊情况: 当 q = 1 时, Sn = n * a1)

## 数组

### 特点
- 用于存储相同类型、连续的数据
- 由于其连续性，可以通过下标和首地址直接计算出不同位置的元素位置，从而获取该值，所以通过下标getvalue时间复杂度是O(1)

## 链表
 单链表、双链表、循环链表

### 单链表

以下单链表的操作要熟练写出

- 链表原地翻转
- 找到链表中点
- 判断链表回文数
- 链表环路检测及环起点计算
- 有序链表合并
- 删除链表倒数第n个结点

#### 哨兵
当往链表中插入一个节点时

```
pNode insertNodeN(pNode head, int pos, int value)
{
    int count;
    pNode temp;
    pNode prev = head;
    temp = (pNode)malloc(sizeof(node));
    temp->data = value;
    if(head == NULL || pos == 0){
        temp->next = head;
        return temp;
    }
    for(count = 1; count < pos && prev->next != NULL; count++){
        prev = prev->next;
    }
    temp->next = prev->next;
    prev->next = temp;      //链

    return head;
}
————————————————
版权声明：本文为CSDN博主「bg2wlj」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/bg2wlj/java/article/details/52300565
```

那如果我们用**哨兵**，即加入一个空头结点，则可以这样写
```
void insertNodeWithSentinelN(const pNode head, int pos, int value)
{
    int count;
    pNode temp;
    pNode prev = head;
    temp = (pNode)malloc(sizeof(node));
    temp->data = value;
    for(count = 0; count < pos && prev->next != NULL; count++){
        prev = prev->next;
    }
    temp->next = prev->next;
    prev->next = temp;      //链
}
————————————————
版权声明：本文为CSDN博主「bg2wlj」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/bg2wlj/java/article/details/52300565
```

哨兵的作用是用一个空节点，让代码逻辑能够统一、简洁明了，不需要额外处理空节点情况

- [带哨兵节点和不带哨兵节点的单链表操作的对比](https://blog.csdn.net/bg2wlj/article/details/52300565)

### LRU
> least recently used

- 最近使用缓存淘汰算法，保留最近使用过的数据
- 为什么做缓存？
  - 通常缓存是将一些常访问的数据存放到**内存**中，以后再用时直接在这里获取，而避免了每次都去磁盘中取数据，磁盘的IO比较耗时
  - 所以缓存的目的是为了提高读取速度，提高性能
- 链表可以实现LRU算法吗？什么优势？
  - 我想，任何数据结构，数组、链表、队列、栈都可以实现，因为LRU是一个存取缓存数据的算法，不依赖具体的数据结构（其实所有算法都是这样）
  - 选择链表要比数组好
    - LRU算法要求，当要访问的数据已经存在结构中时，要标记该元素为最近刚使用，通常需要移动该元素到数据结构的头或尾，所以可能涉及元素移动
    - 当要存储的数据超过最大缓存空间时，要删掉最远访问的数据，此时如果是数组，仍需要移动元素，让空出来的空间可以被复用
    - 数组不擅长元素移动，不如用链表
- 但链表查数据（O(n)）始终不如数组通过下标（O(1)）快，有没有办法让单链表查数据更快些呢？
  - 用散列表？？？？？

## 二分查找
 
- ip地址可以用32位整数来表示，每个ip段最大值是255，8位就够了
 
## 跳表
 
- 为有序的链表添加了多级索引链表
- 通过查找索引链表再找到原始链表中的数据，相比直接在原始链表中查询要更高效
- 跳表查数据时间复杂度可以到O(logn)，空间复杂度是O(n)，即索引链表占用的空间
- 跳表除了缩短了查询的时间复杂度，还由于链表特性能够高效的插入、删除
- redis的复杂存储结构中使用到了跳表
 
## 散列表
 
- 利用数组通过下标查找数据的O(1)特征
- 散列表的两个关键点：散列函数 和 散列冲突解决
 
### 散列函数Hash
- key1 == key2, hash(key1) == hash(key2)
- key1 != key2, 现实中却很难做到 hash(key1) != hash(key2)，这就是三列冲突问题：不同的key指向了同一个散列值
 
### 散列冲突两种解决办法
- 开放寻址法
    - 基本思想是，散列表的结构是数组，且数组中存了元素。发现冲突后，如果要插入元素且因为散列冲突问题，待插入位置已经有其他元素，就想办法找一个空闲的位置
    - 找空闲位置的办法就有：线性探测，就是继续往后一个位置一个位置看
    - 二次探测，不再是一个一个的看了，可能按照2的n次方的步长找
    - 双重散列法，前面散列不是出现了冲突了么，那我多准备几个散列函数，每个散列函数都试试
    - 一个概念--装载因子=数组中元素个数/数组长度
        - 装载因子越大，说明空闲位置越少，冲突可能性越大
- 链表法
         
    ![](/Users/songgeb/Desktop/散列表-链表法.jpg)
     
### 哈希算法
 
就是将任意长度的二进制串映射成固定长度的二进制串
 
4000个汉字的文章做MD5哈希用时不到1ms
 
 
### 区块链对哈希算法的应用
 
区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。
 
区块头保存着 自己区块体 和 上一个区块头 的哈希值。
 
因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。
 
区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。
 
### 散列表和链表一起使用
 
- 散列表可以让查询时间复杂度达到O(1)
- 而链表又能使得删除、添加操作时间复杂度降到O(1)
- 二者结合能够让查询+添加+删除整体的时间复杂度降到O(1)
 
![](/Users/songgeb/Desktop/linkedhashtable.jpg)
 
1. 除了散列表和双向链表，还有一个hnext指针，用于将解决散列冲突用的链表连接起来
2. 使用双向链表因为有前项引用，可以更容易删除元素
 
 
## 树
 
节点的高度、深度、层数
 
![](/Users/songgeb/Desktop/tree.jpg)
 
- 高度：结合生活中的高度，从下往上数，最下面是0
- 深度：结合生活中水深，从水平面往下，最上面是0
- 层数：从上往下，最上面层数是1
 
### 二叉树
 
二叉树的数组存储形式
 
![](/Users/songgeb/Desktop/tree_array.jpg)
 
- 根节点存储下标为1
- 2 * i 是左节点的下标，2 * i + 1是右节点位置
- 对于完全二叉树，相比链式存储，数组存储比较节省空间，只需要存储数据，不用存指针
- 非完全二叉树，会有些浪费
 
#### 二叉搜索树
 
二叉查找树
 
- 因为二叉查找树每个节点的左子树所有节点都比根节点小，右子树总比根节点大；因为这样方便查询数据，所以叫做二叉搜索、查找树
- 当中序打印二叉搜索树时，输出的节点就是排好序的，所以也叫二叉排序树
 
 
**查询、删除、插入时间复杂度**
 
时间复杂度范围：O(1)-O(height)
 
当极端情况下，当二叉搜索树极度不平衡时，比如退化成链表时时间复杂度就是O(n)了
 
如果是完全二叉树的话：时间复杂度最差不会超过O(logn)
 
所以才有了后面的平衡二叉树
 
#### 平衡二叉树
 
平衡二叉树首先是二叉搜索树
 
#### 红黑树
 
红黑树虽不是严格意义上的平衡二叉树，这是综合考虑的结果，所以红黑树的查找性能很好
 
红黑树的定义规定了一些条件和左右旋转、替换节点等操作
 
这些条件或各种旋转的核心目的是**尽可能让这棵树保持平衡**，以方便查找搜索
 
理解红黑树的前提是理解[2-3树](https://www.cnblogs.com/tiancai/p/9072813.html)
 
### 堆排序
 
- 此处的堆是一种数据结构，与内存的堆无关
- 其实是一个完全二叉树
- 这个二叉树符合
    - 每个节点的值都要大于等于它左右子节点的值，即为大顶堆
    - 反之则为小顶堆
 
![](https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg)
 
> 前面有提到，对于完全二叉树，为了节省空间，可以使用数组作为存储结构
 
堆有两个重要操作
 
- 插入元素
- 删除堆顶元素
 
#### 堆化
 
当插入或更改堆中的节点，导致不再是大（小）顶堆时，通过重复与父节点或子节点进行比较、交换，使成为新的大（小）顶堆的过程
 
堆化可以是从下到上，也可上说
 
堆化与更改节点的高度有关，所以堆化的时间复杂度是O(log n)
 
#### 插入元素
 
- 将新元素插入到数组最后
- 从下往上进行堆化
 
#### 删除堆顶元素
 
如果直接删除堆顶元素，再重新调整为大顶堆时会比较麻烦。所以这里有个技巧
 
- 将最后一个元素替换到堆顶位置
- 从新的堆顶元素开始，进行堆化
- 这就相当于删除了堆顶元素
 
#### 堆排序
 
堆排序算法是堆结构的一个经典应用
 
算法的核心操作是 建堆 + 排序
 
建堆：根据乱序数据，构建一个大顶堆
 
建堆思路1：从前到后，从第2个元素开始，通过插入元素的操作构建
建堆思路2：从后往前，因为是完全二叉树，所以数组中[n/2 + 1, n]是叶子节点，无需，我们可以从n/2这个元素开始构建
 
 
#### 用堆解决Top K问题
 
假设求Top K大的数据（Top K小的数据也类似）
 
我们可以用快排，对数据进行排序，然后取出Top K的数据。
 
快排时间复杂度为O(nlogn)
 
也可以用堆来实现
 
1. 新建一个大小为K的小顶堆
2. 将前K个数据插入到堆中
3. 遍历K + 1到n的每个元素
    - 当元素比堆顶元素大，则删除堆顶元素，插入该元素
    - 当元素比堆顶元素小，则不管
4. 所有元素遍历结束，则堆中元素即为Top K大的数据
